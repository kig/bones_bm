<html>
<head>
<style>
input[type=range]:after {
  content: attr(value);
  padding-right: 4px;
}
</style>
</head>
<body>
<div style="display:inline-block;">
  <h3>Performance fiddles</h3>
  <p>Worker count <input id="workercount" type="range" value="4" min="1" max="16" step="1">
  <p>Times to run benchmark <input id="times" type="range" value="100" min="1" max="500" step="1">
  <p>Mesh size in Mverts <input id="mverts" type="range" value="0.125" min="0.125" max="4" step="0.125">
  <p>Use SSE-like version <input id="sse" type="checkbox">
  <p>Single-threaded <input id="singlethreaded" type="checkbox">
</div>
<div style="display:inline-block;">
  <h3>Visual fiddles</h3>
  <p>xFac <input type="range" value="20" min="5" max="320" step="5" onchange="Bones.xFac=1/this.value">
  <p>yFac <input type="range" value="80" min="5" max="320" step="5" onchange="Bones.yFac=1/this.value">
  <p>xtFac <input type="range" value="2" min="0" max="8" step="0.5" onchange="Bones.xtFac=this.value-0">
  <p>ytFac <input type="range" value="4" min="0" max="8" step="0.5" onchange="Bones.ytFac=this.value-0">
</div>
<p><button id="b" disabled="disabled">Run Benchmark</button>
<p id="r">Initializing...</p>
<script src="bones.js"></script>
<script src="webgl-utils.js"></script>

<script id="2d-vertex-shader" type="x-shader/x-vertex">
precision mediump float;
attribute vec4 a_position;
varying float z;

void main() {
  z = a_position.z;
  gl_Position = vec4(a_position);
}
</script>

<script id="2d-fragment-shader" type="x-shader/x-fragment">
precision mediump float;
varying float z;
void main() {
  gl_FragColor = vec4(z,1.0,0.2+0.6*z,1.0);  // green
}
</script>

<script>
var rs = document.querySelectorAll("input[type=range]");
for (var i=0; i<rs.length; i++) {
  rs[i].addEventListener('change', function(){
    this.setAttribute("value", this.value);
  }, false);
}

var prev_mverts = 0;
var prev_workerCount = 0;
var b = document.getElementById('b');
b.disabled = false;
document.getElementById('r').innerHTML = '';

var glC = document.createElement('canvas');
glC.width = glC.height = 400;
document.body.appendChild(glC);
var gl = glC.getContext('experimental-webgl');
var buf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buf);

// setup a GLSL program
var vertexShader = createShaderFromScriptElement(gl, "2d-vertex-shader");
var fragmentShader = createShaderFromScriptElement(gl, "2d-fragment-shader");
var program = createProgram(gl, [vertexShader, fragmentShader]);
gl.useProgram(program);

// look up where the vertex data needs to go.
var positionLocation = gl.getAttribLocation(program, "a_position");
gl.enableVertexAttribArray(positionLocation);
gl.vertexAttribPointer(positionLocation, 4, gl.FLOAT, false, 0, 0);

b.onclick = function() {
  b.disabled = "disabled";
  var workerCount = parseInt(document.getElementById('workercount').value);
  var mverts = parseFloat(document.getElementById('mverts').value);
  var sse = document.getElementById('sse').checked;
  var st = document.getElementById('singlethreaded').checked;
  var times = parseInt(document.getElementById('times').value);
  document.getElementById('r').innerHTML = '';
  Bones.useSSE = sse;
  Bones.workerCount = workerCount;
  Bones.singleThreaded = st;
  if (prev_mverts != mverts || prev_workerCount != workerCount) {
    Bones.initBenchmark(0 | (mverts * 1000000));
    gl.bufferData(gl.ARRAY_BUFFER, 0 | (mverts*1000000*16), gl.DYNAMIC_DRAW);
    prev_mverts = mverts;
    prev_workerCount = workerCount;
  }
  var count = times;
  var arr = [];
  var prev_t = performance.webkitNow();
  var bm = function(t) {
    var now_t = performance.webkitNow();
//     console.log(now_t - prev_t);
    prev_t = now_t;
    var off = 0;
    Bones.dstVertices.forEach(function(ab) {
      gl.bufferSubData(gl.ARRAY_BUFFER, off, ab);
      off += ab.byteLength;
    });
    gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT);
    gl.drawArrays(gl.TRIANGLES, 0, 0 | (125000/16));
    arr.push(t);
    if (count > 0) {
      count--;
      window.webkitRequestAnimationFrame(function() { Bones.runBenchmark(bm); });
    } else {
      var minT = Math.min.apply(Math, arr);
      var maxT = Math.max.apply(Math, arr);
      var avg = arr.reduce(function(s,i){ return s+i; }, 0) / arr.length;
      document.getElementById('r').innerHTML = (
        'min: ' + minT + ' ms<br>' +
        'max: ' + maxT + ' ms<br>' +
        'avg: ' + avg + ' ms<br>'
      );
      var c = document.createElement('canvas');
      c.width = arr.length * 4;
      c.height = 100;
      var ctx = c.getContext('2d');
      arr.forEach(function(e, i) {
        var h = e / maxT * 100;
        ctx.fillRect(i*4, 100-h, 4, h);
      });
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(0, 100 - (avg/maxT)*100, c.width, 1);
      document.getElementById('r').appendChild(c);
      b.disabled = false;
    }
  }
  Bones.runBenchmark(bm);
};
</script>
</body>
</html>
